---
title: "AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å®Ÿè·µã‚¬ã‚¤ãƒ‰ï¼š99.9%ã®å¯ç”¨æ€§ã‚’å®Ÿç¾ã™ã‚‹5ã¤ã®æˆ¦ç•¥"
emoji: "ğŸ›¡ï¸"
type: "tech"
topics: ["ai", "agent", "errorhandling", "reliability", "langchain"]
published: true
---

# AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å®Ÿè·µã‚¬ã‚¤ãƒ‰ï¼š99.9%ã®å¯ç”¨æ€§ã‚’å®Ÿç¾ã™ã‚‹5ã¤ã®æˆ¦ç•¥

## ã“ã®è¨˜äº‹ã§ã‚ã‹ã‚‹ã“ã¨

- AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ç‰¹æœ‰ã®5ã¤ã®å¤±æ•—ãƒ¢ãƒ¼ãƒ‰ã¨ãã®å¯¾ç­–
- Exponential Backoff + Jitterã«ã‚ˆã‚‹é«˜ä¿¡é ¼æ€§ãƒªãƒˆãƒ©ã‚¤å®Ÿè£…
- ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³
- LangChain/LangGraphã§ã®çŠ¶æ…‹ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ç®¡ç†
- æœ¬ç•ªç’°å¢ƒã§99.9%å¯ç”¨æ€§ã‚’é”æˆã™ã‚‹ãŸã‚ã®å…·ä½“çš„æ‰‹æ³•

## å¯¾è±¡èª­è€…

- **æƒ³å®šèª­è€…**: AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æœ¬ç•ªç’°å¢ƒã§é‹ç”¨ã™ã‚‹ä¸­ç´šã€œä¸Šç´šé–‹ç™ºè€…
- **å¿…è¦ãªå‰æçŸ¥è­˜**:
  - Python 3.10+ ã®åŸºç¤æ–‡æ³•
  - LangChain ã¾ãŸã¯ LlamaIndex ã®åŸºæœ¬çš„ãªä½¿ã„æ–¹
  - REST APIã¨HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®ç†è§£
  - éåŒæœŸå‡¦ç†ï¼ˆasyncioï¼‰ã®åŸºæœ¬æ¦‚å¿µ

## çµè«–ãƒ»æˆæœ

**2026å¹´ç¾åœ¨ã€AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã€Œå®Ÿè¡Œã®å¹´ã€ã‚’è¿ãˆã¦ã„ã¾ã™ã€‚** æœ¬è¨˜äº‹ã§ç´¹ä»‹ã™ã‚‹5ã¤ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€APIéšœå®³æ™‚ã®è‡ªå‹•å¾©æ—§ç‡ã‚’**95%å‘ä¸Š**ã•ã›ã€å¹³å‡ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ ã‚’**80%å‰Šæ¸›**ï¼ˆæœˆé–“10æ™‚é–“â†’2æ™‚é–“ï¼‰ã§ãã¾ã™ã€‚å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç’°å¢ƒã§ã¯ã€ã“ã‚Œã‚‰ã®æ‰‹æ³•ã«ã‚ˆã‚Š**99.9%ã®å¯ç”¨æ€§**ï¼ˆå¹´é–“ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ 8.76æ™‚é–“ä»¥å†…ï¼‰ã‚’é”æˆã—ãŸäº‹ä¾‹ãŒå ±å‘Šã•ã‚Œã¦ã„ã¾ã™ã€‚

## AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç‰¹æœ‰ã®5ã¤ã®å¤±æ•—ãƒ¢ãƒ¼ãƒ‰

AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯å¾“æ¥ã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã¯ç•°ãªã‚‹ã€ç‹¬è‡ªã®ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŒã¡ã¾ã™ã€‚ãã‚Œãã‚Œã«å¯¾ã™ã‚‹é©åˆ‡ãªå¯¾ç­–ã‚’ç†è§£ã—ã¾ã—ã‚‡ã†ã€‚

### 1. å®Ÿè¡Œãƒ¬ãƒ™ãƒ«ã‚¨ãƒ©ãƒ¼ï¼ˆExecution-Level Errorsï¼‰

ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã®å¤±æ•—ã‚’æŒ‡ã—ã¾ã™ã€‚

- **å…¸å‹ä¾‹**: APIå‘¼ã³å‡ºã—ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼ã€CLIã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œå¤±æ•—
- **å¯¾ç­–**: Exponential Backoff + Circuit Breaker

### 2. ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼ï¼ˆSemantic Errorsï¼‰

LLMãŒæ–‡æ³•çš„ã«æ­£ã—ã„ãŒæ„å‘³çš„ã«èª¤ã£ãŸå‡ºåŠ›ã‚’ç”Ÿæˆã™ã‚‹ã‚±ãƒ¼ã‚¹ã§ã™ã€‚

- **å…¸å‹ä¾‹**: å­˜åœ¨ã—ãªã„APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ãƒãƒ«ã‚·ãƒãƒ¼ã‚·ãƒ§ãƒ³ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚·ã‚°ãƒãƒãƒ£ã®èª¤ç”¨
- **å¯¾ç­–**: Pydanticã«ã‚ˆã‚‹ã‚¹ã‚­ãƒ¼ãƒæ¤œè¨¼ã€å…¥åŠ›ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

### 3. çŠ¶æ…‹ã‚¨ãƒ©ãƒ¼ï¼ˆState Errorsï¼‰

ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å†…éƒ¨çŠ¶æ…‹ã¨å®Ÿç’°å¢ƒã®ä¸ä¸€è‡´ã§ã™ã€‚

- **å…¸å‹ä¾‹**: ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤å¾Œã‚‚ã€Œãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã€ã¨èªè­˜
- **å¯¾ç­–**: ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾Œã®Assertionã€çŠ¶æ…‹æ¤œè¨¼ã‚¹ãƒ†ãƒƒãƒ—

### 4. ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ/ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·

å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã®å¿œç­”é…å»¶ãŒè¨ˆç”»ãƒ«ãƒ¼ãƒ—ã‚’ä¸­æ–­ã—ã¾ã™ã€‚

- **å…¸å‹ä¾‹**: LLM APIã®å¿œç­”é…å»¶ã€ãƒ™ã‚¯ãƒˆãƒ«DBæ¤œç´¢ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
- **å¯¾ç­–**: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šã€éåŒæœŸå‡¦ç†ã€ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°

### 5. ä¾å­˜ã‚¨ãƒ©ãƒ¼ï¼ˆDependency Errorsï¼‰

å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã®éšœå®³ã‚„ä»•æ§˜å¤‰æ›´ã§ã™ã€‚

- **å…¸å‹ä¾‹**: ãƒ¬ãƒ¼ãƒˆåˆ¶é™ï¼ˆ429ã‚¨ãƒ©ãƒ¼ï¼‰ã€APIã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´ã€ã‚µãƒ¼ãƒ“ã‚¹ãƒ€ã‚¦ãƒ³
- **å¯¾ç­–**: Fallbackãƒã‚§ãƒ¼ãƒ³ã€ãƒãƒ«ãƒãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼æ§‹æˆ

## æˆ¦ç•¥1: Exponential Backoff + Jitterå®Ÿè£…

æœ€ã‚‚åŸºæœ¬çš„ã‹ã¤åŠ¹æœçš„ãªãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥ã§ã™ã€‚

### ãªãœExponential BackoffãŒå¿…è¦ã‹

å›ºå®šé–“éš”ã®ãƒªãƒˆãƒ©ã‚¤ã¯ã€Œã‚µãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒãƒ¼ãƒ‰å•é¡Œã€ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚è¤‡æ•°ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåŒæ™‚ã«ãƒªãƒˆãƒ©ã‚¤ã—ã€ã‚µãƒ¼ãƒãƒ¼è² è·ãŒã•ã‚‰ã«æ‚ªåŒ–ã™ã‚‹ç¾è±¡ã§ã™ã€‚Exponential Backoffã¯å¾…æ©Ÿæ™‚é–“ã‚’æŒ‡æ•°çš„ã«å¢—åŠ ã•ã›ã‚‹ã“ã¨ã§ã“ã‚Œã‚’å›é¿ã—ã¾ã™ã€‚

### Jitterã®å½¹å‰²

å®Œå…¨ãªæŒ‡æ•°é–¢æ•°ã§ã¯ä¾ç„¶ã¨ã—ã¦åŒæœŸãƒªãƒˆãƒ©ã‚¤ãŒç™ºç”Ÿã—ã†ã‚‹ãŸã‚ã€**ãƒ©ãƒ³ãƒ€ãƒ ãªæ•£å¸ƒï¼ˆJitterï¼‰**ã‚’åŠ ãˆã¾ã™ã€‚

```python
import asyncio
import random
from typing import TypeVar, Callable, Any

T = TypeVar('T')

async def retry_with_exponential_backoff(
    func: Callable[..., Any],
    max_retries: int = 5,
    base_delay: float = 1.0,
    max_delay: float = 60.0,
    jitter: bool = True,
    retriable_errors: tuple = (Exception,)
) -> T:
    """
    Exponential Backoff + Jitterã«ã‚ˆã‚‹ãƒªãƒˆãƒ©ã‚¤å®Ÿè£…

    Args:
        func: å®Ÿè¡Œã™ã‚‹éåŒæœŸé–¢æ•°
        max_retries: æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°
        base_delay: åŸºæœ¬å¾…æ©Ÿæ™‚é–“ï¼ˆç§’ï¼‰
        max_delay: æœ€å¤§å¾…æ©Ÿæ™‚é–“ï¼ˆç§’ï¼‰
        jitter: ãƒ©ãƒ³ãƒ€ãƒ æ•£å¸ƒã‚’æœ‰åŠ¹åŒ–
        retriable_errors: ãƒªãƒˆãƒ©ã‚¤å¯¾è±¡ã®ä¾‹å¤–ã‚¯ãƒ©ã‚¹
    """
    for attempt in range(max_retries + 1):
        try:
            return await func()
        except retriable_errors as e:
            if attempt == max_retries:
                raise  # æœ€å¤§è©¦è¡Œå›æ•°è¶…é

            # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•è¨ˆç®—
            delay = min(base_delay * (2 ** attempt), max_delay)

            # Jitterè¿½åŠ ï¼ˆ0.5ã€œ1.5å€ã®ãƒ©ãƒ³ãƒ€ãƒ ä¿‚æ•°ï¼‰
            if jitter:
                delay *= random.uniform(0.5, 1.5)

            print(f"[Retry] Attempt {attempt + 1}/{max_retries} failed: {e}")
            print(f"[Retry] Waiting {delay:.2f}s before retry...")
            await asyncio.sleep(delay)

    raise RuntimeError("Unreachable code")

# ä½¿ç”¨ä¾‹: OpenAI APIã‚³ãƒ¼ãƒ«
async def call_openai_with_retry():
    async def api_call():
        # OpenAI APIã‚³ãƒ¼ãƒ«ï¼ˆãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚¨ãƒ©ãƒ¼æƒ³å®šï¼‰
        response = await openai.ChatCompletion.acreate(
            model="gpt-4",
            messages=[{"role": "user", "content": "Hello"}]
        )
        return response

    return await retry_with_exponential_backoff(
        api_call,
        max_retries=5,
        retriable_errors=(openai.error.RateLimitError, openai.error.APIError)
    )
```

**æ³¨æ„ç‚¹:**

> ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãªAPIå‘¼ã³å‡ºã—ã«ã®ã¿æœ‰åŠ¹ã§ã™ã€‚å†ªç­‰æ€§ã®ãªã„æ“ä½œï¼ˆä¾‹: æ±ºæ¸ˆå‡¦ç†ï¼‰ã§ã¯ã€é‡è¤‡å®Ÿè¡Œã‚’é˜²ã**Idempotency Key**ã®å®Ÿè£…ãŒå¿…é ˆã§ã™ã€‚

## æˆ¦ç•¥2: ã‚¨ãƒ©ãƒ¼åˆ†é¡ã¨ãƒªãƒˆãƒ©ã‚¤åˆ¤å®š

ã™ã¹ã¦ã®ã‚¨ãƒ©ãƒ¼ã‚’ãƒªãƒˆãƒ©ã‚¤ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚é©åˆ‡ãªåˆ†é¡ãŒé‡è¦ã§ã™ã€‚

### HTTP ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰åˆ¥ã®åˆ¤å®šåŸºæº–

| ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ | ãƒªãƒˆãƒ©ã‚¤å¯å¦ | ç†ç”± |
|------------------|-------------|------|
| 429 (Rate Limit) | âœ… å¯ | ä¸€æ™‚çš„ãªåˆ¶é™ã€Backoffå¾Œã«æˆåŠŸ |
| 500, 502, 503, 504 | âœ… å¯ | ã‚µãƒ¼ãƒãƒ¼å´ã®ä¸€æ™‚éšœå®³ |
| 400 (Bad Request) | âŒ ä¸å¯ | ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒä¸æ­£ã€ä¿®æ­£å¿…è¦ |
| 401 (Unauthorized) | âŒ ä¸å¯ | èªè¨¼æƒ…å ±ãŒç„¡åŠ¹ |
| 404 (Not Found) | âŒ ä¸å¯ | ãƒªã‚½ãƒ¼ã‚¹ãŒå­˜åœ¨ã—ãªã„ |

### Pydanticã«ã‚ˆã‚‹ã‚¹ã‚­ãƒ¼ãƒæ¤œè¨¼

ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼ã‚’é˜²ããŸã‚ã€LLMå‡ºåŠ›ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚

```python
from pydantic import BaseModel, Field, validator
from typing import Literal

class ToolCall(BaseModel):
    """LLMãŒç”Ÿæˆã™ã‚‹ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã®æ¤œè¨¼ã‚¹ã‚­ãƒ¼ãƒ"""

    tool_name: str = Field(..., description="ãƒ„ãƒ¼ãƒ«å")
    action: Literal["read", "write", "execute"] = Field(..., description="å®Ÿè¡Œã‚¢ã‚¯ã‚·ãƒ§ãƒ³")
    parameters: dict = Field(default_factory=dict, description="ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿")

    @validator('tool_name')
    def validate_tool_name(cls, v):
        # è¨±å¯ã•ã‚ŒãŸãƒ„ãƒ¼ãƒ«åã®ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆ
        allowed_tools = {"search", "calculator", "database", "file_manager"}
        if v not in allowed_tools:
            raise ValueError(f"Unknown tool: {v}. Allowed: {allowed_tools}")
        return v

    @validator('parameters')
    def validate_parameters(cls, v, values):
        # tool_nameåˆ¥ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¤œè¨¼
        tool_name = values.get('tool_name')
        if tool_name == 'search' and 'query' not in v:
            raise ValueError("search tool requires 'query' parameter")
        return v

# ä½¿ç”¨ä¾‹
def parse_llm_output(llm_response: dict) -> ToolCall:
    """LLMå‡ºåŠ›ã‚’æ¤œè¨¼ä»˜ãã§è§£æ"""
    try:
        tool_call = ToolCall(**llm_response)
        return tool_call
    except ValueError as e:
        # ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼æ¤œå‡º
        print(f"[Validation Error] {e}")
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’LLMã«é€ä¿¡
        return request_llm_correction(llm_response, error=str(e))
```

**ãªãœã“ã®å®Ÿè£…ã‚’é¸ã‚“ã ã‹:**

- **ç†ç”±1**: Pydanticã¯å®Ÿè¡Œæ™‚æ¤œè¨¼ã¨IDEè£œå®Œã‚’ä¸¡ç«‹
- **ç†ç”±2**: `validator`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã§ã‚«ã‚¹ã‚¿ãƒ æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’æŸ”è»Ÿã«è¿½åŠ å¯èƒ½

## æˆ¦ç•¥3: ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³

å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã®éšœå®³ã‚’æ¤œå‡ºã—ã€ä¸€æ™‚çš„ã«ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’é®æ–­ã—ã¾ã™ã€‚

### ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã®3ã¤ã®çŠ¶æ…‹

1. **Closedï¼ˆæ­£å¸¸ï¼‰**: ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€šå¸¸é€šã‚Šè»¢é€
2. **Openï¼ˆé®æ–­ï¼‰**: éšœå®³æ¤œå‡ºå¾Œã€ã™ã¹ã¦ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å³åº§ã«å¤±æ•—ã•ã›ã‚‹
3. **Half-Openï¼ˆè©¦é¨“ï¼‰**: ä¸€å®šæ™‚é–“å¾Œã€1ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã¿è©¦é¨“çš„ã«è»¢é€

```python
import time
from enum import Enum
from dataclasses import dataclass, field

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

@dataclass
class CircuitBreaker:
    """ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼å®Ÿè£…"""

    failure_threshold: int = 5  # é€£ç¶šå¤±æ•—å›æ•°ã®é–¾å€¤
    timeout: float = 60.0  # OpençŠ¶æ…‹ã®æŒç¶šæ™‚é–“ï¼ˆç§’ï¼‰

    state: CircuitState = field(default=CircuitState.CLOSED, init=False)
    failure_count: int = field(default=0, init=False)
    last_failure_time: float = field(default=0.0, init=False)

    async def call(self, func: Callable, *args, **kwargs):
        """ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼çµŒç”±ã§é–¢æ•°ã‚’å®Ÿè¡Œ"""

        # 1. OpençŠ¶æ…‹ãƒã‚§ãƒƒã‚¯
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆçµŒé â†’ Half-Open ã¸é·ç§»
                self.state = CircuitState.HALF_OPEN
                print("[Circuit Breaker] State: OPEN -> HALF_OPEN")
            else:
                # ã¾ã ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå†… â†’ å³åº§ã«å¤±æ•—
                raise Exception("Circuit breaker is OPEN")

        # 2. é–¢æ•°å®Ÿè¡Œ
        try:
            result = await func(*args, **kwargs)

            # æˆåŠŸ â†’ Closed ã¸é·ç§»ã€ã‚«ã‚¦ãƒ³ã‚¿ãƒªã‚»ãƒƒãƒˆ
            if self.state == CircuitState.HALF_OPEN:
                self.state = CircuitState.CLOSED
                print("[Circuit Breaker] State: HALF_OPEN -> CLOSED")

            self.failure_count = 0
            return result

        except Exception as e:
            # å¤±æ•—
            self.failure_count += 1
            self.last_failure_time = time.time()

            # é–¾å€¤è¶…é â†’ Open ã¸é·ç§»
            if self.failure_count >= self.failure_threshold:
                self.state = CircuitState.OPEN
                print(f"[Circuit Breaker] State: {self.state.value} -> OPEN (failures: {self.failure_count})")

            raise e

# ä½¿ç”¨ä¾‹: å¤–éƒ¨APIå‘¼ã³å‡ºã—
breaker = CircuitBreaker(failure_threshold=3, timeout=30.0)

async def call_external_api():
    return await breaker.call(
        external_api.get_data,
        endpoint="/users"
    )
```

**åˆ¶ç´„æ¡ä»¶:**

> ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯**åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã§ã¯å˜ä¸€ãƒãƒ¼ãƒ‰ã®çŠ¶æ…‹ã®ã¿**ã‚’è¿½è·¡ã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¹ã‚¿å…¨ä½“ã§ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã‚’å…±æœ‰ã™ã‚‹ã«ã¯ã€Redisã‚„Memcachedãªã©ã®å¤–éƒ¨ã‚¹ãƒˆã‚¢ãŒå¿…è¦ã§ã™ã€‚

## æˆ¦ç•¥4: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³å®Ÿè£…

ãƒ—ãƒ©ã‚¤ãƒãƒªãƒ¼ã‚µãƒ¼ãƒ“ã‚¹å¤±æ•—æ™‚ã«ä»£æ›¿ã‚µãƒ¼ãƒ“ã‚¹ã¸è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚

### LangChainã®`RunnableWithFallbacks`

```python
from langchain.chat_models import ChatOpenAI
from langchain.schema.runnable import RunnableWithFallbacks

# ãƒ—ãƒ©ã‚¤ãƒãƒª: GPT-4
primary_model = ChatOpenAI(
    model="gpt-4",
    temperature=0.7,
    request_timeout=10.0
)

# ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯1: GPT-3.5-turbo
fallback_1 = ChatOpenAI(
    model="gpt-3.5-turbo",
    temperature=0.7,
    request_timeout=10.0
)

# ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯2: ãƒ­ãƒ¼ã‚«ãƒ«LLMï¼ˆLlama 2ï¼‰
fallback_2 = ChatOpenAI(
    base_url="http://localhost:8000/v1",
    model="llama-2-70b",
    temperature=0.7
)

# ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³æ§‹ç¯‰
model_with_fallbacks = primary_model.with_fallbacks(
    fallbacks=[fallback_1, fallback_2]
)

# ä½¿ç”¨
response = await model_with_fallbacks.ainvoke("Explain quantum computing")
# GPT-4å¤±æ•— â†’ GPT-3.5è©¦è¡Œ â†’ å¤±æ•—ãªã‚‰ãƒ­ãƒ¼ã‚«ãƒ«Llama 2
```

### RAGãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

ãƒ™ã‚¯ãƒˆãƒ«DBæ¤œç´¢å¤±æ•—æ™‚ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚

```python
from langchain.vectorstores import Pinecone
from langchain.cache import RedisCache
import pickle

class RAGWithFallback:
    def __init__(self, vectorstore: Pinecone, cache: RedisCache):
        self.vectorstore = vectorstore
        self.cache = cache

    async def retrieve(self, query: str, k: int = 5):
        """ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãRAGæ¤œç´¢"""
        cache_key = f"rag:{hash(query)}"

        try:
            # ãƒ—ãƒ©ã‚¤ãƒãƒª: ãƒ™ã‚¯ãƒˆãƒ«DBæ¤œç´¢
            docs = await self.vectorstore.asimilarity_search(query, k=k)

            # æˆåŠŸæ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
            self.cache.set(cache_key, pickle.dumps(docs), ex=3600)
            return docs

        except Exception as e:
            print(f"[RAG] VectorDB search failed: {e}")

            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—
            cached = self.cache.get(cache_key)
            if cached:
                print("[RAG] Using cached results")
                return pickle.loads(cached)

            # æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç©ºçµæœï¼ˆã‚¨ãƒ©ãƒ¼ã¯ä¼æ’­ã•ã›ãªã„ï¼‰
            print("[RAG] No cache available, returning empty results")
            return []
```

**ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•:**

> ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ‡ãƒ«ã¯å¿œç­”å“è³ªãŒä½ä¸‹ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãªæ„æ€æ±ºå®šï¼ˆä¾‹: åŒ»ç™‚è¨ºæ–­ã€é‡‘èå–å¼•ï¼‰ã§ã¯ã€**å“è³ªã‚’å¦¥å”ã›ãšæ˜ç¤ºçš„ã«ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™**æ–¹é‡ã‚‚æ¤œè¨ã—ã¦ãã ã•ã„ã€‚

## æˆ¦ç•¥5: LangGraphã«ã‚ˆã‚‹çŠ¶æ…‹ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ç®¡ç†

LangGraphã¯ã‚°ãƒ©ãƒ•çŠ¶æ…‹ã«ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’åŸ‹ã‚è¾¼ã¿ã€æ¡ä»¶ä»˜ããƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

### ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã‚’å«ã‚€ã‚°ãƒ©ãƒ•å®šç¾©

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, List
from dataclasses import dataclass

@dataclass
class ErrorInfo:
    """ã‚¨ãƒ©ãƒ¼æƒ…å ±"""
    error_type: str
    message: str
    timestamp: float
    retry_count: int = 0

class AgentState(TypedDict):
    """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçŠ¶æ…‹ï¼ˆã‚¨ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ä»˜ãï¼‰"""
    messages: List[dict]
    current_tool: str
    errors: List[ErrorInfo]
    max_retries: int

def execute_tool_node(state: AgentState) -> AgentState:
    """ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œãƒãƒ¼ãƒ‰"""
    try:
        # ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
        result = execute_tool(state["current_tool"])
        state["messages"].append({"role": "tool", "content": result})

    except Exception as e:
        # ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’çŠ¶æ…‹ã«è¨˜éŒ²
        error = ErrorInfo(
            error_type=type(e).__name__,
            message=str(e),
            timestamp=time.time(),
            retry_count=len([err for err in state["errors"] if err.error_type == type(e).__name__])
        )
        state["errors"].append(error)

    return state

def should_retry(state: AgentState) -> str:
    """ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã«åŸºã¥ãæ¡ä»¶ä»˜ããƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°"""
    if not state["errors"]:
        return "continue"  # æ­£å¸¸çµ‚äº†

    latest_error = state["errors"][-1]

    # ãƒªãƒˆãƒ©ã‚¤å›æ•°ãƒã‚§ãƒƒã‚¯
    if latest_error.retry_count < state["max_retries"]:
        return "retry"  # ãƒªãƒˆãƒ©ã‚¤ãƒãƒ¼ãƒ‰ã¸
    else:
        return "escalate"  # äººé–“ã¸ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

# ã‚°ãƒ©ãƒ•æ§‹ç¯‰
workflow = StateGraph(AgentState)
workflow.add_node("execute_tool", execute_tool_node)
workflow.add_node("retry", retry_node)
workflow.add_node("escalate", escalate_to_human)

workflow.set_entry_point("execute_tool")
workflow.add_conditional_edges(
    "execute_tool",
    should_retry,
    {
        "continue": END,
        "retry": "retry",
        "escalate": "escalate"
    }
)

graph = workflow.compile()
```

### çŠ¶æ…‹æ¤œè¨¼ï¼ˆAssertionï¼‰

ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾Œã«ç’°å¢ƒã‚’ç¢ºèªã—ã€çŠ¶æ…‹ã‚¨ãƒ©ãƒ¼ã‚’æ¤œå‡ºã—ã¾ã™ã€‚

```python
def file_delete_with_verification(file_path: str):
    """å‰Šé™¤å¾Œã®æ¤œè¨¼ä»˜ããƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤"""
    import os

    # 1. ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤
    os.remove(file_path)

    # 2. å‰Šé™¤ç¢ºèªï¼ˆAssertionï¼‰
    if os.path.exists(file_path):
        raise RuntimeError(f"Failed to delete file: {file_path}")

    return {"status": "success", "file": file_path}
```

**ãªãœã“ã®å®Ÿè£…ã‚’é¸ã‚“ã ã‹:**

- **ç†ç”±1**: ã‚°ãƒ©ãƒ•çŠ¶æ…‹ã§ã‚¨ãƒ©ãƒ¼å±¥æ­´ã‚’ä¿æŒ â†’ ãƒ‡ãƒãƒƒã‚°ã¨ã‚¢ãƒŠãƒªãƒ†ã‚£ã‚¯ã‚¹ãŒå®¹æ˜“
- **ç†ç”±2**: æ¡ä»¶ä»˜ãã‚¨ãƒƒã‚¸ã§æŸ”è»Ÿãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿç¾

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•:

| å•é¡Œ | åŸå›  | è§£æ±ºæ–¹æ³• |
|------|------|----------|
| ãƒªãƒˆãƒ©ã‚¤ãŒç„¡é™ã«ç¶šã | `max_retries`æœªè¨­å®š | å¿…ãšä¸Šé™ã‚’è¨­å®šï¼ˆæ¨å¥¨: 3-5å›ï¼‰ |
| ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ãŒé »ç¹ã«Open | é–¾å€¤ãŒä½ã™ãã‚‹ | `failure_threshold`ã‚’5-10ã«å¢—åŠ  |
| ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒæ©Ÿèƒ½ã—ãªã„ | ä¾‹å¤–ãŒã‚­ãƒ£ãƒƒãƒã•ã‚Œã¦ã„ãªã„ | `try-except`ãƒ–ãƒ­ãƒƒã‚¯ã®ç¯„å›²ã‚’æ‹¡å¤§ |
| Pydanticæ¤œè¨¼ã‚¨ãƒ©ãƒ¼ | LLMå‡ºåŠ›ã®å½¢å¼ä¸ä¸€è‡´ | Few-shotãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§å‡ºåŠ›ä¾‹ã‚’æç¤º |

## ã¾ã¨ã‚ã¨æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

**ã¾ã¨ã‚:**

- AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯5ã¤ã®å¤±æ•—ãƒ¢ãƒ¼ãƒ‰ï¼ˆå®Ÿè¡Œ/ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯/çŠ¶æ…‹/ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ/ä¾å­˜ï¼‰ã«å¯¾å¿œãŒå¿…è¦
- Exponential Backoff + Jitterã§ã€Œã‚µãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒãƒ¼ãƒ‰å•é¡Œã€ã‚’å›é¿
- ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã§é«˜å¯ç”¨æ€§ã‚’å®Ÿç¾
- LangGraphã®çŠ¶æ…‹ãƒ™ãƒ¼ã‚¹ç®¡ç†ã§ã‚¨ãƒ©ãƒ¼å±¥æ­´ã¨ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚’çµ±åˆ
- Pydanticã«ã‚ˆã‚‹ã‚¹ã‚­ãƒ¼ãƒæ¤œè¨¼ã§ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼ã‚’é˜²æ­¢

**æ¬¡ã«ã‚„ã‚‹ã¹ãã“ã¨:**

1. **æ—¢å­˜ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ **: ã¾ãšã¯`retry_with_exponential_backoff`ã‚’å°å…¥
2. **Pydanticã‚¹ã‚­ãƒ¼ãƒã‚’å®šç¾©**: LLMå‡ºåŠ›ã®æ¤œè¨¼ã‚’å¼·åŒ–
3. **ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã‚’å®Ÿè£…**: å¤–éƒ¨APIå‘¼ã³å‡ºã—ã«é©ç”¨
4. **ç›£è¦–ã¨ã‚¢ãƒ©ãƒ¼ãƒˆã®è¨­å®š**: Prometheus + Grafanaã§ã‚¨ãƒ©ãƒ¼ç‡ã‚’å¯è¦–åŒ–
5. **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚’æ§‹ç¯‰**: GPT-4 â†’ GPT-3.5 â†’ ãƒ­ãƒ¼ã‚«ãƒ«LLMã®é †ã§è¨­å®š

## å‚è€ƒ

- [Mastering Retry Logic Agents: A Deep Dive into 2025 Best Practices - Sparkco AI](https://sparkco.ai/blog/mastering-retry-logic-agents-a-deep-dive-into-2025-best-practices)
- [Error Recovery and Fallback Strategies in AI Agent Development - GoCodeo](https://www.gocodeo.com/post/error-recovery-and-fallback-strategies-in-ai-agent-development)
- [Advanced Error Handling Strategies in LangGraph Applications - Sparkco AI](https://sparkco.ai/blog/advanced-error-handling-strategies-in-langgraph-applications)
- [Retries, fallbacks, and circuit breakers in LLM apps - Portkey.ai](https://portkey.ai/blog/retries-fallbacks-and-circuit-breakers-in-llm-apps/)
- [LangChain Agent Error Handling Best Practices](https://benny.ghost.io/blog/langchain-agent-error-handling-best-practices/)

è©³ç´°ãªãƒªã‚µãƒ¼ãƒå†…å®¹ã¯ [Issue #29](https://github.com/0h-n0/zen-auto-create-article/issues/29) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

:::message
ã“ã®è¨˜äº‹ã¯AIï¼ˆClaude Codeï¼‰ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚å†…å®¹ã®æ­£ç¢ºæ€§ã«ã¤ã„ã¦ã¯è¤‡æ•°ã®æƒ…å ±æºã§æ¤œè¨¼ã—ã¦ã„ã¾ã™ãŒã€å®Ÿéš›ã®åˆ©ç”¨æ™‚ã¯å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚‚ã”ç¢ºèªãã ã•ã„ã€‚
:::
