---
title: "DSPy活用パターン完全ガイド：プロンプト自動最適化で精度50%向上を実現"
emoji: "🔧"
type: "tech"
topics: ["dspy", "llm", "python", "ai", "promptengineering"]
published: false
---

# DSPy活用パターン完全ガイド：プロンプト自動最適化で精度50%向上を実現

## この記事でわかること

- DSPyフレームワークの基本概念と従来のLLMフレームワークとの違い
- ChainOfThought、ReAct、RAGなど代表的な5つの実装パターンの使い分け
- 実務で効果的な2段階最適化手法と精度改善の具体的数値
- マルチモーダルタスクへの適用方法とエンタープライズ採用事例

## 対象読者

- **想定読者**: LLMアプリケーション開発の経験がある中級者〜上級者
- **必要な前提知識**:
  - Python 3.9以上の基本文法
  - LLM（Large Language Model）の基礎知識
  - プロンプトエンジニアリングの経験
  - LangChainやOpenAI APIの利用経験があると理解が深まります

## 結論・成果

DSPyは「プログラミング—プロンプティングではなく—LM」という革新的なアプローチにより、手作業でのプロンプト調整から開発者を解放します。実際の導入事例では**精度が28.6%から42.9%へ約50%向上**（ユニファ社マルチモーダル事例）、**フレームワークオーバーヘッドが3.53ms**（LangChainの10msと比較して65%削減）という成果が報告されています。

SmartHRでは2段階DSPy最適化により、オンライン指標から自動でオフライン評価関数を構築し、UX指標と安全性のバランスを実現しました。

## DSPyとは何か：従来フレームワークとの違い

DSPy（Declarative Self-improving Python）はStanford大学NLP Labが開発したフレームワークで、「プロンプトを手作業で調整する」従来の手法から脱却します。

### DSPyの基本構造

DSPyでは入出力の**型定義（Signature）**と**評価指標**を定義すれば、プロンプトは自動生成されます。

```python
import dspy

# 1. 型定義（Signature）
class QA(dspy.Signature):
    """質問に対して段階的に推論して回答する"""
    question = dspy.InputField()
    answer = dspy.OutputField()

# 2. モジュール選択とデータセットで自動最適化
cot = dspy.ChainOfThought(QA)
optimizer = dspy.MIPROv2(metric=evaluate)
optimized_cot = optimizer.compile(cot, trainset=trainset)
```

**利点**: モデル変更時も同じデータセットで再コンパイルするだけで、手作業の調整が不要になります。

**注意点:**
> 最低でも10-20例のトレーニングデータが必要です。不適切な評価関数では最適化が効果を発揮しません。

## 代表的な実装パターン

### 1. ChainOfThought：推論タスク

```python
import dspy
dspy.configure(lm=dspy.LM('openai/gpt-4', api_key="YOUR_API_KEY"))
math = dspy.ChainOfThought("question -> answer: float")
response = math(question="2つのサイコロで合計が2になる確率は？")
```

### 2. ReAct：外部ツール統合

```python
react = dspy.ReAct("question -> answer", tools=[search_wikipedia])
response = react(question="エッフェル塔の高さは？")
```

### 3. RAG（検索拡張生成）

```python
class RAG(dspy.Module):
    def __init__(self):
        self.retrieve = dspy.Retrieve(k=3)
        self.generate = dspy.ChainOfThought("context, question -> answer")
```

### 4. 分類（型制約）

```python
from typing import Literal
class SentimentClassifier(dspy.Signature):
    text = dspy.InputField()
    sentiment: Literal["positive", "negative", "neutral"] = dspy.OutputField()
```

## 実務で効果を出す2段階最適化手法

SmartHRが実践した手法を解説します。

### 第1段階：評価関数（Judge）の自動学習

実運用データ（SlackリアクションGood/Bad/Copy）から評価基準を学習します。

```python
class JudgeSignature(dspy.Signature):
    question = dspy.InputField()
    answer = dspy.InputField()
    score: int = dspy.OutputField(desc="1-3のスコア")

judge = dspy.ChainOfThought(JudgeSignature)
judge_optimizer = dspy.GEPA(metric=lambda ex, pred: abs(ex.score - pred.score) < 0.5)
optimized_judge = judge_optimizer.compile(judge, trainset=user_feedback_data)
```

### 第2段階：生成プロンプトの最適化

学習したJudgeを評価関数として使用します。

```python
generator = dspy.ChainOfThought("question -> answer")

# 多目的評価関数（UX + 安全性）
def multi_objective_metric(example, prediction):
    judge_score = optimized_judge(
        question=example.question, answer=prediction.answer
    ).score
    safety_score = check_safety(prediction.answer)
    return 0.6 * judge_score + 0.4 * safety_score

optimizer = dspy.MIPROv2(metric=multi_objective_metric)
final_generator = optimizer.compile(generator, trainset=qa_dataset)
```

**効果**: SmartHRでは、UXと安全性のバランスを自動化で実現し、評価サイクルを大幅に短縮しました。

## マルチモーダルタスクへの適用

2026年1月、ユニファ社が画像処理タスクでDSPyを適用した事例を紹介します。

### 画像内人数カウントの実装

```python
import dspy
from PIL import Image

lm = dspy.LM('gemini/gemini-2.5-flash', api_key="YOUR_API_KEY")
dspy.configure(lm=lm)

class CountPeople(dspy.Signature):
    image = dspy.InputField()
    reasoning = dspy.OutputField()
    count: int = dspy.OutputField()

counter = dspy.ChainOfThought(CountPeople)
img = Image.open("crowd.jpg")
result = counter(image=dspy.Image.from_PIL(img))
```

**成果数値:**
- **最適化前**: 28.6%の精度
- **最適化後**: 42.9%の精度（約50%向上）
- **データセット**: 68枚（train 40 / val 13 / test 15）
- **手法**: GEPA（推論プロセスをフィードバックに含める）

**注意点:**
> Gemma3 4bでは42.9%が上限でしたが、大規模モデルでは80%の精度を確認済み。

## よくある問題と解決方法

| 問題 | 解決方法 |
|------|----------|
| 最適化後も精度が上がらない | 評価指標を見直し、トレーニングデータを20例以上に増やす |
| 最適化に時間がかかる | `dspy.configure(cache=True)`でキャッシュ有効化 |
| ReActでツールが呼ばれない | ツール関数のdocstringを具体的に記述 |

## DSPy vs LangChain：使い分け

| 指標 | DSPy | LangChain |
|------|------|-----------|
| オーバーヘッド | 3.53ms | 10ms |
| 自動最適化 | ✅ | ❌ |
| エコシステム | 発展中 | 成熟 |

**DSPy**: プロンプト自動最適化、低レイテンシが必要な場合
**LangChain**: 豊富なツール統合、プロトタイプ迅速構築が必要な場合

## まとめと次のステップ

**まとめ:**
- DSPyは**プロンプト自動最適化**により、手作業の試行錯誤を削減
- **ChainOfThought、ReAct、RAG**など5つの標準パターンでほとんどのタスクに対応
- **2段階最適化**（評価関数学習 → 生成最適化）が実務で効果的
- **精度50%向上、レイテンシ65%削減**など具体的な成果が実証済み
- **マルチモーダル対応**で画像処理タスクにも適用可能

**次にやるべきこと:**
1. **DSPyのインストールとチュートリアル実行**: 公式ドキュメントの[Getting Started](https://dspy.ai/)で環境構築
2. **小規模データセット（10-20例）で実験**: 既存のLLMタスクをDSPyで再実装し、精度比較
3. **評価指標の設計**: タスクに適した評価関数を定義（自動最適化の鍵）
4. **GEPA/MIPROv2の使い分け**: GEPAは推論プロセス重視、MIPROv2は大規模データ向け

## 参考

- [DSPy公式サイト](https://dspy.ai/)
- [GitHub: stanfordnlp/dspy](https://github.com/stanfordnlp/dspy)
- [ユニファ開発者ブログ: DSPyによるマルチモーダルタスクのプロンプト自動調整](https://tech.unifa-e.com/entry/2026/01/12/070000)
- [SmartHR Tech Blog: 2段階DSPyで評価指標を作る](https://tech.smarthr.jp/entry/2026/01/15/113732)
- [フレクト: DSPyを用いたLLMの自動プロンプトチューニング](https://cloud.flect.co.jp/entry/2026/01/20/122507)
- [Databricks Blog: Optimizing Databricks LLM Pipelines with DSPy](https://www.databricks.com/blog/optimizing-databricks-llm-pipelines-dspy)
- [Qdrant: DSPy vs LangChain Comparison](https://qdrant.tech/blog/dspy-vs-langchain/)
- [Jina AI: DSPy: 通常のプロンプトエンジニアリングとは一線を画す](https://jina.ai/ja/news/dspy-not-your-average-prompt-engineering/)

詳細なリサーチ内容は [Issue #35](https://github.com/0h-n0/zen-auto-create-article/issues/35) を参照してください。

---

:::message
この記事はAI（Claude Code）により自動生成されました。内容の正確性については複数の情報源で検証していますが、実際の利用時は公式ドキュメントもご確認ください。
:::
